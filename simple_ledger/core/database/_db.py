"""
A generic reusable database class using sqlmodel in python, a purposed usecase is db.py
"""

import os
from pathlib import Path
from typing import Any, Literal, Optional, Type, Union
from sqlmodel import Field, SQLModel, Session, create_engine, select
from pprint import pformat

from simple_ledger.core.database import database_logger as db_logger
from simple_ledger.utils.file_handling.file_ops import create_folder, create_file

# The above code is importing necessary modules and classes from various libraries such as os,
# pathlib, typing, sqlmodel, pprint,  and configuration module. It defines a class
# that inherits from SQLModel and creates a database engine using the create_engine function. It also
# defines a function that creates a session with the database engine and executes a select query. The
# purpose of this code is not clear without additional context.


class DB:

    """
    The DB class provides methods for creating, reading, updating, and deleting records in a database
    using SQLAlchemy.
    """

    def __init__(
        self,
        *,
        db_api: str,
        db_name: str,
        db_dir: Union[str, Path],
        echo: Union[bool, str],
        hide_parameters: bool,
    ) -> None:
        """
        This is a constructor function that initializes a database connection and creates tables in the
        database.

        Args:
          db_api (str): A string representing the database API to be used (e.g. "sqlite", "mysql",
        "postgresql").
          db_name (str): The name of the database that will be created or used.
          db_dir (Union[str, Path]): The `db_dir` parameter is a string or `Path` object that represents the
        directory where the database file will be stored. It is used in the `__init__` method to create the
        directory if it does not exist and to construct the engine URL.
          echo (Union[bool, str]): A boolean or string value that determines whether or not to echo SQL
        statements generated by the engine. If set to True, all SQL statements will be printed to the
        console. If set to False, no SQL statements will be printed. If set to a string, only SQL statements
        matching the string will be
          hide_parameters (bool): A boolean parameter that determines whether or not to hide the parameters
        in the SQL queries executed by the engine. If set to True, the parameters will be replaced with
        question marks in the query.
        """
        self.db_api: str = db_api
        self.db_name: str = db_name
        self.db_dir: str | Path = db_dir

        db_logger.info("Creating DB ...")

        # Engine:
        # Engine: Pre Init Works
        try:
            """
            if (self.db_api != None) and (self.db_name != None):
            This code block is creating a directory for the database file if it does not exist and
            creating the database file using the `touch` command. If an exception occurs during this
            process, it logs the error and raises a critical error message.
            """
            self.create_data_base_directory_and_file()
        except Exception as e:
            db_logger.exception(
                f"Exception While Creating DB File: ", exc_info=e, stack_info=True
            )

        self.engine_url: str = (
            f"{self.db_api}:///{str(self.db_dir)}{os.path.sep}{self.db_name}"
        )

        db_logger.debug(
            f"Creating with parameters: {self.db_api=},{self.db_name=}, {self.db_dir=} {self.engine_url=}"
        )

        try:
            db_logger.info("Trying to create DB Engine ...")

            self.engine: Any = create_engine(
                self.engine_url,
                echo=echo,
                hide_parameters=hide_parameters,
            )
            db_logger.info("Created DB Engine Successfully ...")
        except Exception as e:
            db_logger.exception(
                f"Exception Occurred !!!:", exc_info=e, stack_info=True, stacklevel=3
            )
            db_logger.critical(f"Application need to be stopped ...")

        self.create_table_metadata()

    @db_logger.timer
    def create_data_base_directory_and_file(self, force: bool = False):
        try:
            create_folder(Path(self.db_dir), force, parents=True)
            create_file(
                path=Path(Path(self.db_dir) / self.db_name), force=force, parents=True
            )
        except Exception as e:
            db_logger.exception(e)

    @db_logger.timer
    def create_table_metadata(self) -> bool:
        """
        This function creates metadata for a database using a bound engine and returns a boolean
        indicating success or failure.

        Returns:
          a boolean value. If the metadata creation is successful, it returns True. If there is an
        exception, it prints the error message and returns False.
        """
        try:
            db_logger.info(
                "Trying to create table meta data, i.e Tables in the database"
            )
            SQLModel.metadata.create_all(
                self.engine
            )  # need to change this field else this will cause duplicate tables in created DBs
            return True
        except Exception as e:
            db_logger.exception(f"Exception Occurred !!!:", exc_info=e, stack_info=True)
            db_logger.critical(
                "Couldn't create the tables in the DB. Stop the Application ..."
            )

            return False

    @db_logger.timer
    def insert_records(self, *, model_object: Union[list[SQLModel], SQLModel]) -> bool:
        """
        The function inserts one or more SQLModel objects into a database session and returns a boolean
        indicating success or failure.

        Args:
          model_object (Union[list[SQLModel], SQLModel]): The `model_object` parameter is a required
        keyword-only argument of the `insert_records` method. It can either be a single instance of a
        `SQLModel` object or a list of `SQLModel` objects. These objects represent the data that needs
        to be inserted into the database. The method

        Returns:
          a boolean value. If the records are successfully inserted into the database, it returns True.
        If there is an exception during the insertion process, it returns False.
        """
        try:
            with Session(self.engine) as session:
                db_logger.info("Inserting Data")
                db_logger.debug(
                    f"Inserting the given Data into the db using {session=}"
                )
                if type(model_object) == list:
                    db_logger.debug(
                        f"Inserting Multiple Data into the db with {session=}"
                    )
                    session.add_all(model_object)
                else:
                    db_logger.debug(f"Inserting an Data into the db with {session=}")
                    session.add(model_object)
                session.commit()
                db_logger.debug("Given data Successfully committed to the db ...")
                db_logger.debug("Data Insertion Successful !!! ...")
                del model_object
                return True
        except Exception as e:
            db_logger.exception(f"Exception Occurred !!!:", exc_info=e, stack_info=True)
            db_logger.warning(f"Failure in inserting data ...")
            del model_object

            return False

    @db_logger.timer
    def read_records(
        self,
        *,
        model_class: SQLModel,
        where_and_to: Optional[dict[str, Any]] = None,
        fetch_mode: Optional[Literal["all", "one", "many"]] = "many",
        how_many: Optional[int] = 10,
    ) -> list[Type[SQLModel]] | Type[SQLModel] | None:
        """
        This function reads records from a SQL database based on specified parameters and returns the
        results in a specified fetch mode.

        Args:
          model_class (SQLModel): The SQLAlchemy model class representing the database table to read
        records from.
          where_and_to (Optional[dict[str, Any]]): `where_and_to` is a dictionary that contains the
        conditions to filter the records to be fetched. The keys of the dictionary represent the
        attributes of the model class and the values represent the values that the attributes should
        have. If `where_and_to` is None, all records will be fetched.
          fetch_mode (Optional[Literal["all", "one", "many"]]): `fetch_mode` is an optional parameter
        that specifies how the records should be fetched from the database. It can take one of three
        values: "all", "one", or "many". If "all" is specified, all the records that match the query
        will be fetched. If "one". Defaults to many
          how_many (Optional[int]): `how_many` is an optional integer parameter that specifies the
        number of records to fetch when `fetch_mode` is set to "many". If `how_many` is not specified or
        is set to None, the default value of 10 will be used. If `fetch_mode` is not set. Defaults to 10

        Returns:
          The function `read_records` returns the result of executing a SQL query on a database using
        the provided `model_class` and `where_and_to` parameters. The result is fetched based on the
        `fetch_mode` and `how_many` parameters, and the fetched data is returned. The return type can be
        any depending on the `fetch_mode` and the fetched data.
        """
        try:
            with Session(self.engine) as session:
                db_logger.info("Reading Data from the DB ...")
                db_logger.debug(
                    f"Reading from the table: `{model_class.__name__}` with {session=}"
                )
                if where_and_to != None:
                    db_logger.info(
                        "Gotcha We have an condition to search for in the DB ..."
                    )
                    db_logger.debug(
                        f"Search in the DB with condition being: {where_and_to}"
                    )
                    if len(list(where_and_to.keys())) == 1:
                        db_logger.debug(f"Hahaan , We just have one condition...")
                        statement: Type[select] = select(model_class).where(
                            getattr(model_class, list(where_and_to.keys())[0])
                            == list(where_and_to.values())[0]
                        )
                        db_logger.debug(
                            f"Created SQL Statement to execute in the DB ..."
                        )
                    if len(list(where_and_to.keys())) > 1:
                        db_logger.debug(
                            f"Hahaan , We just have got set of conditions ,i.e => {len(list(where_and_to.keys()))} ..."
                        )
                        statement: Type[select] = select(model_class)
                        try:
                            db_logger.debug(
                                f"Creating SQL Statement for multiple conditions given..."
                            )
                            for attribute, value in list(where_and_to.items()):
                                statement = statement.where(
                                    getattr(model_class, attribute) == value
                                )
                            else:
                                db_logger.debug(
                                    f"Created SQL Statement to execute in the DB ..."
                                )
                        except Exception as e:
                            db_logger.exception(
                                f"Exception Occurred !!!:", exc_info=e, stack_info=True
                            )
                            db_logger.critical(
                                "Couldn't Create statement for mutliple conditions given ..."
                            )

                else:
                    db_logger.info("No condition is provided to search in the DB")
                    statement: Type[select] = select(model_class)
                    db_logger.debug("Created SQL Statement to execute ...")
                result = session.exec(statement)
                # need to log herer
                if fetch_mode == "all":
                    db_logger.debug(f"Fetching All Data; since {fetch_mode=}")
                    db_logger.debug("Returning All Data")
                    return result.all()
                elif fetch_mode == "one":
                    try:
                        db_logger.debug(f"Fetching One Data; since {fetch_mode=}")
                        db_logger.debug("Returning A Data")
                        return result.one()  # handle error
                    except Exception:
                        db_logger.exception(e)
                        db_logger.warning(f"Couldn't fetch Data from the DB")
                elif (fetch_mode == "many") and (how_many != None) and (how_many > 0):
                    db_logger.debug(
                        f"Fetching As many data as {how_many}; since {fetch_mode=}"
                    )
                    db_logger.debug(f"Returning {how_many} datum")
                    return result.fetchmany(how_many)
                else:  # if no fetch_mode specified
                    db_logger.debug(
                        "Returning all Data ; Since no fetch mode is specified"
                    )
                    return result.all()
        except Exception as e:
            db_logger.exception(f"Caught an UnExpected Exception: {e}")
            db_logger.warning("Got No Data with me now ...")

    @db_logger.timer
    def update_records(
        self,
        *,
        model_class: SQLModel,
        where_and_to: dict[str, Any],
        with_what: dict[str, Any],
    ) -> None:
        """
        This function updates records in a database using SQLAlchemy ORM.

        Args:
          model_class (SQLModel): The SQLModel class that represents the database table to be updated.
          where_and_to (dict[str, Any]): `where_and_to` is a dictionary that specifies the conditions to
        locate the record(s) to be updated in the database table. The keys of the dictionary represent
        the column names and the values represent the values to be matched. For example, if the table
        has columns "id", "name", and
          with_what (dict[str, Any]): `with_what` is a dictionary containing the attributes and their
        updated values that you want to update in the database table. The keys of the dictionary
        represent the attribute names and the values represent the updated values for those attributes.
        """
        with Session(self.engine) as session:
            db_logger.debug(f"Trying to update data with {session=}")
            try:
                result = self.read_records(
                    model_class=model_class,
                    where_and_to=where_and_to,
                    fetch_mode="one",
                )

                for attribute, value in with_what.items():
                    setattr(
                        result,
                        attribute,
                        value,
                    )
                    db_logger.debug(f"Updating {result}.{attribute} with {value}")
            except Exception as e:
                self.insert_records(model_object=result)
                db_logger.warning(f"Exception Doi...")
                db_logger.exception(f"Caught an Exception: {e}")
            session.close()
            db_logger.debug(f"Closed the session: {session}")

    @db_logger.timer
    def delete_records(
        self,
        *,
        model_class: SQLModel,
        where_and_to: dict[str, Any],
        delete_mode: Literal["all", "one"] = "one",
    ) -> bool:
        """
        The function deletes records from a SQL database based on a given model class and a dictionary
        of where conditions, with the option to delete all matching records or just one.

        Args:
          model_class (SQLModel): The SQLModel class representing the database table from which records
        will be deleted.
          where_and_to (dict[str, Any]): `where_and_to` is a dictionary that contains the condition(s)
        to be used in the `WHERE` clause of the SQL `DELETE` statement. The keys of the dictionary
        represent the column names and the values represent the values to be matched. For example, if
        `where_and_to` is
          delete_mode (Literal["all", "one"]): The `delete_mode` parameter is a string literal that
        specifies the mode of deletion. It can be either "one" or "all". If it is set to "one", only one
        record that matches the given condition will be deleted. If it is set to "all", all records that
        match. Defaults to one

        Returns:
          a boolean value indicating whether the deletion of records was successful or not. True is
        returned if the deletion was successful, and False is returned if there was an error.
        """
        try:
            with Session(self.engine) as session:
                db_logger.debug(
                    f"Trying to delete on the model class: {model_class} ; with {session=}"
                )
                statement = select(model_class).where(
                    getattr(model_class, list(where_and_to.keys())[0])
                    == list(where_and_to.values())[0]
                )
                result = session.exec(statement)
                if delete_mode == "one":
                    db_logger.debug(f"Deleting with {delete_mode=}")
                    session.delete(list(result)[0])

                elif delete_mode == "all":
                    db_logger.debug(f"Deleting with {delete_mode=}")
                    session.delete(result)
                session.commit()
                db_logger.debug(f"Committed Data to DB after deletion process")
                return True
        except Exception as e:
            db_logger.exception(f"Caught an Exception while deletion process: {e}")
            return False
